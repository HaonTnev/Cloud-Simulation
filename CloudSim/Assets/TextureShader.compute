// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture3D<float4> tex : register(u0);
RWTexture3D<float4> nextGen : register(u1);

 uint xSize;
 uint ySize;
 uint zSize;

[numthreads(8, 8, 8)]
void CSMain (uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID)
{

    float xf = xSize;
    float yf = ySize;
    float zf = zSize;
    
    tex[id.xyz] = float4(id.x/xf,id.y/yf,id.z/zf,1);

    
    uint numNeighbors = 0;
    bool alive = false;
    if (tex[id.xyz].x >.9f)
    {
        alive = true;
    }
    // Loop over neighboring cells in a 3x3x3 cube (including the current cell)
    for (int i = -1; i <= 1; i++)
    {
        for (int j = -1; j <= 1; j++)
        {
            for (int k = -1; k <= 1; k++)
            {
                // Exclude self in check
                if(i == 0 && j == 0 && k == 0)
                    continue;

                float3 neighbor = float3( id.x+i, id.y+j, id.z+k);
                if(tex[neighbor].x > .8f)
                {
                    numNeighbors++;
                }
            }
        }
    }
    
    if (alive  && (numNeighbors < 5 || numNeighbors > 6))
    {
        nextGen[id.xyz] = float4(0,0,0,1);
    }
    else if (alive && (numNeighbors >= 4 && numNeighbors <= 7))
    {
        nextGen[id.xyz] = float4(1.f,0,0,1);
    }
    else if (!alive && (numNeighbors == 4 || numNeighbors == 5))
    {
        nextGen[id.xyz] = float4(1.f,0,0,1);
    }
   // else nextGen[id.xyz] = float4(1, 0,.5f,.1f); // Debug col
}